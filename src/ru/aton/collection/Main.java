package ru.aton.collection;

import java.util.HashMap;
import java.util.Map;

/*
Номер телефона имеет формат x(xxx)xxx-xx-xx и минимум 11 (10 без кода страны) цифр в записи.
Диапазон типа данных int - от -2147483648 до 2147483647, что не делает возможным его
использование в качестве ключа или иного поля, по которому возможен поиск,
что накладывает дополнительное ограничение на реализацию коллекции.
Кроме того, важно отметить, что поиск по ключу за O(1) обеспечивают только одна коллекция (ArrayList) в случае,
если ключом является число и вставка осуществляется в ячейку с
определённым индексом, и одна коллекция-мапа (HashMap), которая поодерживает,
в отличие от ArrayList, ключ, являющийся типом long, который нам и требуется в связи
с соответствующим номером телефона.
Альтернативный вариант с переписыванием ArrayList,
в котором индекс был бы long вместо int невозможен, так как в его основе находится массив ограниченной длины.
HashMap подвержена коллизиям из-за определения hash-кода, при этом коллизии в задаче будут примерно такими, что на один хэш
будет приходиться 1,6 элемента.
Важно в этом случае, что цепочка с одним хэш-кодом, в которой больше 8 элементов, в Java превратится в двоичное дерево,
но в нашем случае этого не произойдёт,
то есть, в доступ к элементу будет по-прежнему осуществляться за O(1).
Худший сценарий, когда остальные > 11 млн. номеров одинаковы, в решении не рассматривался.
Объём памяти, занимаемый данными (без записей, только телефон-имя)
в задаче протестирован последними тремя строками программы.
При этом полученные показатели ниже, чем простой расчёт возможного объёма информации в коллекции
(телефон-имя на 18758328 записей, которые, соответственно, без дублей на 30 млн., оцениваются в форматах
Long-String UTF-16 в 1650732864 + 1500666240 байт, что больше значений, полученных опытным путём), что может говорить
о возможной оптимизации процесса JVM. При расчёте даже не учитывались Hash и ссылка на следующий элемент, которые также
есть в ноде и должны учитываться в объёме занимаемой памяти.
Таким образом, реализация через HashMap выбрана наиболее оптимальной в условиях задачи.
 */

public class Main {

    public static void main(String[] args) {

        Map<Long, String> stringMap = new HashMap<>();

        for (long i = 0; i < 18758328; i++) {
            stringMap.put(81111111111L + i, "aaaaabbbbbcccccddddd");
        }
        for (int i = 0; i < 11241672; i++) {
            stringMap.put(81111111111L + i, "aaaaabbbbbcccccddddd");
        }


        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Used memory:" + usedMemory + "bytes");

    }

}
